---
title: "Detección GBM - analisis de los factores de riesgo"
output: html_notebook
---

```{r library load}
library(jsonlite)
library(corrplot)
library(Amelia)
library(caret)
library(e1071)
library(survival)
library(ranger)
library(mice)
library(RColorBrewer)
library(gridExtra)
library(ggplot2)
library(ggpmisc)
library(data.table)
```

Este script muestra los pasos seguidos para el análisis de los factores de riesgo que pueden llevar al desarrollo de un glioblastoma multiforme (GBM) y no sobrevivir. Además, se incluyen también las características extraidas de los escáneres MRI de los pacientes.


```{r load dataset}
load(file = 'dataset_images_12month.Rda')

dataset_images_12month$cause_of_death_at_12months_follow_up <- as.factor(dataset_images_12month$cause_of_death_at_12months_follow_up)
dataset_images_12month$vital_status_at_12months_follow_up <- as.factor(dataset_images_12month$vital_status_at_12months_follow_up)
dataset_images_12month$gender <- as.factor(dataset_images_12month$gender)

```

# Cargar características extraidas de las imágenes

Hay que cargar el fichero CSV creado a partir de las características extraidas de las imágenes y unirlo con el dataset de los factores de riesgo usando el ID de los pacientes. Además, como no se disponen imágenes de todos los pacientes, se eliminarán aquellos pacientes de los que solo se dispongan metadatos.

```{r}
filename <- "features/features.csv"
dataset_features <- read.csv(filename, header=TRUE)

dataset_images_merge <- merge(dataset_images_12month, dataset_features, by="case_id", all=TRUE)
dataset_images_merge <- dataset_images_merge[!is.na(dataset_images_merge$tumor_volume),]
```

# Ajustar el nuevo dataset

Hay que comprobar si hace falta ajustar el tipo de dato de ciertas variables. Además, cambiar la forma en la que estaban representados los NA en el CSV de las características para que coincida con el dataset de los factores de riesgo.

```{r}
sapply(dataset_images_merge, class)
dataset_images_merge$tumor_mri_type <- as.factor(dataset_images_merge$tumor_mri_type)
dataset_images_merge$edema_mri_type <- as.factor(dataset_images_merge$edema_mri_type)

dataset_images_merge[dataset_images_merge == "NaN"] <- NA
```

## EXPLORATORY DATA ANALYSIS

En este dataset se diferencian tres variables de clase distintas: cause_of_death_at_12months_follow_up o la causa de la muerte si es que la hay a los 12 meses, vital_status_at_12months_follow_up o el estado del paciente (vivo/muerto) a los 12 meses y life_expectancy o los dias que han pasado desde el diagnóstico del GBM hasta su muerte si es que la hay.

```{r EDA}
dataset_images_merge_red <- dataset_images_merge

# Missing values
missmap(dataset_images_merge_red, col=c("black", "grey"), legend=FALSE)

cause_of_death_index <- which(names(dataset_images_merge_red) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
vital_status_index <- which(names(dataset_images_merge_red) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
life_expectancy_index <- which(names(dataset_images_merge_red) == 'life_expectancy', arr.ind = TRUE)

dataset_images_merge_red[c(cause_of_death_index, vital_status_index, life_expectancy_index)] <- NULL 

# Elminar las entradas con más del 30% de las variables con NA
# Tamaño del dataset antes de eliminar entradas
dim(dataset_images_merge_red)
dataset_images_merge_red <- dataset_images_merge_red[which(rowMeans(!is.na(dataset_images_merge_red)) > 0.7), ]
dataset_images_merge <- dataset_images_merge[which(rowMeans(!is.na(dataset_images_merge[, -c(cause_of_death_index, vital_status_index, life_expectancy_index)])) > 0.7), ]

# Eliminar variables con más del 40% de los valores con NA
dataset_images_merge_red <- cbind(dataset_images_merge_red[, which(colMeans(!is.na(dataset_images_merge_red[,])) > 0.6)], dataset_images_merge[,c(cause_of_death_index, vital_status_index, life_expectancy_index)])

cause_of_death_index <- which(names(dataset_images_merge_red) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
vital_status_index <- which(names(dataset_images_merge_red) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
life_expectancy_index <- which(names(dataset_images_merge_red) == 'life_expectancy', arr.ind = TRUE)

numeric_var_indexes_all <- c(which(sapply(dataset_images_merge_red, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_images_merge_red, class) == 'integer', arr.ind = TRUE))
numeric_var_indexes <- numeric_var_indexes_all[-which(numeric_var_indexes_all ==  life_expectancy_index, arr.ind = TRUE)]

non_numeric_var_indexes_all <- which(sapply(dataset_images_merge_red, class) == 'factor', arr.ind = TRUE)
non_numeric_var_indexes <- non_numeric_var_indexes_all[-which(non_numeric_var_indexes_all ==  cause_of_death_index, arr.ind = TRUE)]
non_numeric_var_indexes <- non_numeric_var_indexes[-which(non_numeric_var_indexes ==  vital_status_index, arr.ind = TRUE)]

# Tamaño del dataset tras eliminar entradas
dim(dataset_images_merge_red)

missmap(dataset_images_merge_red, col=c("black", "grey"), legend=FALSE)
# Histogramas de las variables numéricas
par(mfrow=c(1, 4))
for(i in 1:length(numeric_var_indexes)) {
    hist(dataset_images_merge_red[,numeric_var_indexes[i]], main=names(dataset_images_merge_red)[numeric_var_indexes[i]])
}
# Barplots de las variables no numéricas
par(mfrow=c(1, 3))
for(i in 1:length(non_numeric_var_indexes)) {
    barplot(table(dataset_images_merge_red[,non_numeric_var_indexes[i]]), main=names(dataset_images_merge_red)[non_numeric_var_indexes[i]], las=2)
}
# Correlación de las variables numéricas
par(mfrow=c(1, 1))
correlation_numeric_vars <- cor(dataset_images_merge_red[, c(numeric_var_indexes, life_expectancy_index)], use = "complete.obs")
corrplot(correlation_numeric_vars, method="circle")

# Valores del skewness
for(i in 1:length(numeric_var_indexes)){
  print(names(dataset_images_merge_red)[numeric_var_indexes[i]])
  print(skewness(dataset_images_merge_red[, numeric_var_indexes[i]], na.rm = TRUE))
}

```
De los datos extraidos en este punto se han realizado las siguientes observaciones.

* En lo que respecta a los valores que faltan (NA), el mapa presenta una alta cantidad de NA para las variables:

  - ethnicity
  - race
  - number_of_pack_years_smoked
  - years_high_alcohol_quantity_consumed
  - alcohol consumption
  - tobacco_smoking_history
  - life_expectancy
  
* De las cuales las primeras dos no llegan al 60% de datos completos y las otras dos si. Se ha decidido el eliminar aquellas variables que no llegan al 60%, teniendo que imputar los valores de las variables number_of_pack_years_smoked y years_high_alcohol_quantity_consumed en la fase de preprocesado.

* La variable life_expectancy también contiene muchos valores NA pero no preocupan por el momento, ya que estos valores se corresponden a pacientes que siguen vivos. Además, debido a que el dataset corresponde a datos que se han ido recogiendo durante más de un año, la variable también contiene valores mayores que 365. Esto significa que estos pacientes estaban vivos a los 12 meses pero han fallecido mientras estaban en seguimiento más adelante. Aun así, esto no se puede saber a los 12 meses que es cuando se está realizando el análisis por lo que estas entradas se tienen que reemplazar por NA.

* En la variable tumor_size hay un único valor NA que tendrá que ser imputado.

* Además, las entradas que no llegan al 70% de variables definidas se han eliminado del dataset, eliminando un total de 4 entradas.

* En general, los valores del skewness no son muy altos, solo algunas características extraidas tienen un valor mayor. Para no cambiar los valores de las características extraidas, no se plantea la corrección del skewness en el apartado de preprocesamiento.


```{r}
summary(dataset_images_merge_red$life_expectancy)

dataset_images_merge_red[which(dataset_images_merge_red$life_expectancy > 365, arr.ind = TRUE), names(dataset_images_merge_red) == 'life_expectancy'] <- NA

summary(dataset_images_merge_red$life_expectancy)
```
Por cada variable de clase se crea un dataset distinto con el objetivo de analizarlas por separado.

## Eliminación de variables altamente correladas
Se van a eliminar las variables altamente correladas del dataset para evitar problemas de multicolinearidad y overfitting.

```{r}
dim(dataset_images_merge_red)
# find attributes that are highly corrected
cutoff <- 0.8
highlyCorrelated <- findCorrelation(correlation_numeric_vars, cutoff=cutoff)
# create a new dataset without highly correlated features
dataset_images_12month_features <- dataset_images_merge_red[,-highlyCorrelated]
dim(dataset_images_12month_features)
```

## Análisis del estado del paciente (vivo/muerto)

Se analiza los valores de las variables dependiendo del estado del paciente, si está vivo o muerto, y la relación que tienen con la variable de clase.

```{r EDA vital status}
dataset_vital_status <- dataset_images_12month_features[, -c(life_expectancy_index, cause_of_death_index)]

class_val_index <- which(names(dataset_vital_status) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
numeric_var_indexes_vital <- c(which(sapply(dataset_vital_status, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_vital_status, class) == 'integer', arr.ind = TRUE))
non_numeric_var_indexes_vital <- which(sapply(dataset_vital_status, class) == 'factor', arr.ind = TRUE)
non_numeric_var_indexes_vital <- non_numeric_var_indexes_vital[-which(non_numeric_var_indexes_vital ==  class_val_index, arr.ind = TRUE)]

summary(dataset_vital_status)

# Boxplots para las variables numéricas
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[1:4]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[5:8]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[9:12]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[13:16]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[17:20]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[21:24]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[25:28]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[29:32]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))

#Barplots
barplot(table(dataset_vital_status[, c(non_numeric_var_indexes_vital[2], class_val_index)]), 
        main = names(dataset_vital_status)[non_numeric_var_indexes_vital[2]], 
        col = brewer.pal(n = 2, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Female", "Male"),
                           fill = brewer.pal(n = 2, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_vital_status[, c(non_numeric_var_indexes_vital[3], class_val_index)]), 
        main = names(dataset_vital_status)[non_numeric_var_indexes_vital[3]], 
        col = brewer.pal(n = 5, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Reformed smoker (<15)", "Reformed smoker (>15)", "Reformed smoker (?)",
                                      "Current smoker", "Lifelong non-smoker"),
                           fill = brewer.pal(n = 5, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_vital_status[, c(non_numeric_var_indexes_vital[4], class_val_index)]), 
        main = names(dataset_vital_status)[non_numeric_var_indexes_vital[4]], 
        col = c("white", "blue", "brown", "coral", "cyan", "darkgray", "darkblue", "darkolivegreen", "gray", "gold",
                "green", "lavender", "khaki", "lightblue", "orange", "palegreen", "navy", "red", "salmon", "purple",
                "yellow", "turquoise"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40))


# Class imbalance
cbind(Label_freq=table(dataset_vital_status$vital_status_at_12months_follow_up), Label_percent=prop.table(table(dataset_vital_status$vital_status_at_12months_follow_up))*100)
```
Con los datos obtenidos se concluyen los siguientes puntos.

* Se observa que el dataset está más o menos balanceado (40% de pacientes muertos y 60% vivos).

* Analizando los boxplots y los barplots creados, no se puede determinar una separación clara entre las distintas variables de clase. La realidad es que hay ciertas tendencias, por ejemplo, parece que la mayoría de los que han muerto tenian un tamaño de tumor algo más alto como mediana, o que los supervivientes tienen una mediana mayor respecto al contraste, disimilitud y entropía del tumor, pero no se observa que ninguna variable sea determinante para predicción de el estado del paciente.

# Análisis de la causa de muerte

Se analiza la causa de la muerte siendo en su mayoría por GBM, aunque aparecen otras posibles causas. Además, hay que tener un cuenta que el 60% de los pacientes siguen vivos.

```{r EDA cause of death}
dataset_cause <- dataset_images_12month_features
dataset_cause <- dataset_cause[which(dataset_cause$vital_status_at_12months_follow_up == 'Deceased', arr.ind = TRUE), ]

dataset_cause <- dataset_cause[, -c(life_expectancy_index, vital_status_index)]
class_val_index <- which(names(dataset_cause) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
numeric_var_indexes_cause <- c(which(sapply(dataset_cause, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_cause, class) == 'integer', arr.ind = TRUE))
non_numeric_var_indexes_cause <- which(sapply(dataset_cause, class) == 'factor', arr.ind = TRUE)
non_numeric_var_indexes_cause <- non_numeric_var_indexes_cause[-which(non_numeric_var_indexes_cause ==  class_val_index, arr.ind = TRUE)]
dataset_cause <- droplevels(dataset_cause)

summary(dataset_cause)

# Boxplots for numeric variables
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[1:4]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[5:8]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[9:12]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[13:16]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[17:20]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[21:24]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[25:28]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[29:32]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))

# Barplots for non-numeric variables
barplot(table(dataset_cause[, c(non_numeric_var_indexes_cause[2], class_val_index)]), 
        main = names(dataset_cause)[non_numeric_var_indexes_cause[2]], 
        col = brewer.pal(n = 2, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Female", "Male"),
                           fill = brewer.pal(n = 2, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_cause[, c(non_numeric_var_indexes_cause[3], class_val_index)]), 
        main = names(dataset_cause)[non_numeric_var_indexes_cause[3]], 
        col = brewer.pal(n = 5, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Reformed smoker (<15)", "Reformed smoker (>15)", "Reformed smoker (?)",
                                      "Current smoker", "Lifelong non-smoker"),
                           fill = brewer.pal(n = 5, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_cause[, c(non_numeric_var_indexes_cause[4], class_val_index)]), 
        main = names(dataset_cause)[non_numeric_var_indexes_cause[4]], 
        col = c("white", "blue", "brown", "coral", "cyan", "darkgray", "darkblue", "darkolivegreen", "gray", "gold",
                "green", "lavender", "khaki", "lightblue", "orange", "palegreen", "navy", "red", "salmon", "purple",
                "yellow", "turquoise"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40))

# Class imbalance
cbind(Label_freq=table(dataset_cause$cause_of_death_at_12months_follow_up), Label_percent=prop.table(table(dataset_cause$cause_of_death_at_12months_follow_up))*100)

```
Con los datos obtenidos se concluyen los siguientes puntos.

* Se observa que el dataset está no está balanceado (58.33% de pacientes muertos a causa de GBM, 33.33% por Malingnant Brain Neoplasm y 8.33% por Postoperative Edema). Además, solo hay un paciente que ha muerto por Postoperative Edema por lo que no se pueden sacar unas conclusiones concluyentes respecto a esta causa.

* En lo que respecta a los boxplots y barplots empleados, no se observa una clara diferencia entre las variables. Si se ha observado que aquellos pacientes con un peso alto tienden ha haber muerto a causa de GBM o por un edema postoperatorio, pero esto puede no ser determinante debido al bajo porcentaje de pacientes que han sufrido de este contratiempo. Otras variables como compactness o glcm_correlation también diferencian a pacientes con distintas causas de muerte pero esta diferencia no es muy significativa.

* Se observa que ciertas características del paciente muerto por un edema postoperatorio difieren bastante de las de los demás pero, como se ha dicho antes, una paciente no es suficiente para sacar conclusiones.

# Análisis de la esperanza de vida

La esperanza de vida se corresponde con los dias que transcurren desde la primera daignósis hasta la muerte.

```{r EDA life expectancy}
dataset_life_expect <- dataset_images_12month_features

dataset_life_expect <- dataset_life_expect[, -c(cause_of_death_index, vital_status_index)]
class_val_index <- which(names(dataset_life_expect) == 'life_expectancy', arr.ind = TRUE)
numeric_var_indexes_life_expect <- c(which(sapply(dataset_life_expect, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_life_expect, class) == 'integer', arr.ind = TRUE))
numeric_var_indexes_life_expect <- numeric_var_indexes_life_expect[-which(numeric_var_indexes_life_expect ==  class_val_index, arr.ind = TRUE)]
non_numeric_var_life_expect <- which(sapply(dataset_life_expect, class) == 'factor', arr.ind = TRUE)

dataset_life_expect <- droplevels(dataset_life_expect)
summary(dataset_life_expect)
# Scatter plots for numeric variables
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[1:4]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[5:8]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[9:12]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[13:16]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[17:20]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[21:24]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[25:28]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[29:32]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))

# Boxplots
featurePlot(y=dataset_life_expect[, non_numeric_var_life_expect[2]],
            x=dataset_life_expect$life_expectancy, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 10)))
featurePlot(y=dataset_life_expect[, non_numeric_var_life_expect[3]],
            x=dataset_life_expect$life_expectancy, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 0)))
featurePlot(y=dataset_life_expect[, non_numeric_var_life_expect[4]],
            x=dataset_life_expect$life_expectancy, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 10)))

# Class variable
plot(density(dataset_life_expect$life_expectancy[which(!is.na(dataset_life_expect$life_expectancy))]), main=names(dataset_life_expect)[class_val_index])
```
* Se puede ver que ciertas variables como skewness o kutosis muestran una relación más o menos lineal con la esperanza de vida. En otras, en cambio, esta relación no está tan clara.

Para complementar el análisis de la supervivencia, se procede a la creación de modelos de Cox para calcular las probabilidades de supervivencia a los 12 meses. En un principio, debido a los valores NA que contiene el dataset, se crea una regresión de Cox por cada variable, y así analizar el impacto de cada una de ellas independientemente del resto.

## IMPUTACIÓN DE LAS VARIABLES

Con el objetivo de poder analizar el impacto que todas las variables tienen en la supervivencia del paciente y calcular las regresiones de Cox y RandomForest, se procede a la imputación de los valores definidos como NA en el dataset. Para la imputación de las variables se emplea el método Predictive Mean Matching (PMM).

```{r}
# Cantidad de valores NA que hay que imputar
sum(is.na(dataset_images_12month_features))

na_loc <- which(is.na(dataset_images_12month_features), arr.ind=TRUE)
na_loc_colums <- unique(na_loc[,2])
na_loc_colums <- na_loc_colums[-which(na_loc_colums == life_expectancy_index, arr.ind=TRUE)]

# Variables con valores NA presentes
names(dataset_images_12month_features)[na_loc_colums]

dataset_images_12month_features_completed <- dataset_images_12month_features[, -life_expectancy_index]

imp_pmm <- mice(dataset_images_12month_features_completed, m = 3, method= "pmm", printFlag = FALSE, seed = 7)
dataset_images_12month_features_completed <- complete(imp_pmm)

#imp_pmm <- mice(dataset_images_12month_features_completed, m = 1, method= "pmm", printFlag = FALSE, seed = 3)
#dataset_images_12month_features_completed <- complete(imp_pmm)

# Cantidad de valores NA después de imputar
print(sum(is.na(dataset_images_12month_features_completed)))

dataset_images_12month_features_completed$life_expectancy <- dataset_images_12month_features$life_expectancy
```
## REGRESIÓN DE COX

El primer método empleado para determinar las probabilidades de supervivencia del paciente es la regresión de Cox. Una vez contamos con el dataset con los valores imputados, procedemos a calcular la regresión de Cox con todas las variables disponibles.
```{r}
dataset_survival <- dataset_images_12month_features_completed
dataset_survival$vital_status <- as.numeric(dataset_survival$vital_status)
dataset_survival$vital_status[which(dataset_survival$vital_status == 2)] <- 0

cox.model.all_vars <- coxph(Surv(time_monitored, vital_status) ~ age + gender + bmi + alcohol_consumption + years_high_alcohol_quantity_consumed + tobacco_smoking_history + number_of_pack_years_smoked + weight_in_kg + height_in_cm + tumor_site + tumor_size_in_cm, data = dataset_survival)
summary(cox.model.all_vars, digits = 3)
cox.model.all_vars.fit <- survfit(cox.model.all_vars)

df <- data.frame(cox.model.all_vars.fit$time, cox.model.all_vars.fit$surv, "Cox")
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

anova(cox.model.all_vars)
```

Mediante los tests ANOVA se ha determinado la relevancia de las variables en el modelo de Cox. La mayoría de ellos no parecen ser relevantes (p < 0.05), estando por debajo de ese valor únicamente las variables de edad, BMI y historial de consumo de alcohol (age, bmi y alcohol_consumption). Para asegurarnos de que esto se cumple, creamos un segundo modelo de Cox solo con las variables determinadas como relevantes y comparamos los resultados de los dos modelos mediante los tests ANOVA.

```{r}
cox.model.select_vars <- coxph(Surv(time_monitored, vital_status) ~ age + bmi + alcohol_consumption, data = dataset_survival)
# summary(cox.model.select_vars, digits = 3)
cox.model.select_vars.fit <- survfit(cox.model.select_vars)
summary(cox.model.select_vars, digits = 3)

df <- data.frame(cox.model.select_vars.fit$time, cox.model.select_vars.fit$surv, "Cox")
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

anova(cox.model.select_vars)
anova(cox.model.select_vars, cox.model.all_vars, test = "LRT")
```

El test ANOVA muestra un valor p > 0.05 por lo que podemos concluir que la diferencia entre ambos modelos no es relevante, confirmando que las variables seleccionadas son suficiente para calcular el modelo de supervivencia y que son las más determinantes a la hora de predecir las probabilidades de supervivencia del paciente que padece de GBM.

## RANDOM FOREST

Para comparar el modelo de supervivencia obtenido mediante la regresión de Cox con otro modelo se implementa otro modelo basádo en el algoritmo Random Forest.  Se calcula el modelo de supervivencia de todas las variables y obtenemos las importancias asignadas a cada una de las variables por el modelo mediante el método de permutación. Esta métrica nos permite determinan como aumenta el error en la predicción al eliminar la variable.

```{r}
# p value atea
names(dataset_survival) <- janitor::make_clean_names(names(dataset_survival), use_make_names = TRUE)

r_fit.all_vars <- ranger(Surv(time = time_monitored, event = vital_status) ~  age + gender + bmi + alcohol_consumption + years_high_alcohol_quantity_consumed + tobacco_smoking_history + number_of_pack_years_smoked + tumor_site + tumor_size_in_cm + height_in_cm + weight_in_kg, data = dataset_survival,
                         num.trees = 525,
                         importance = "permutation",
                         splitrule = "extratrees",
                         num.random.splits = 20,
                         scale.permutation.importance = TRUE,
                         verbose = TRUE)

surv_prob <- data.frame(r_fit.all_vars$survival)
avg_prob_allvars <- sapply(surv_prob, mean)

df <- data.frame(r_fit.all_vars$unique.death.times, avg_prob_allvars, rep("RF", length(r_fit.all_vars$unique.death.times)))
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

# Plot importancias
var_imp <- data.frame(sort(round(r_fit.all_vars$variable.importance, 4), decreasing = TRUE))
names(var_imp) <- "importance"
var_imp

# Calcular el p-value para ver si las variables son representativas o no para el modelo
importance_pvalues(r_fit.all_vars, method = "altmann", data = dataset_survival, formula = Surv(time = time_monitored, event = vital_status) ~  age + gender + bmi + alcohol_consumption + years_high_alcohol_quantity_consumed + tobacco_smoking_history + number_of_pack_years_smoked + tumor_site + tumor_size_in_cm)
```

Con las variables de más importancia, es decir, aquellas que introducen un mayor error en la predicción en caso de eliminarse y que tienen un valor p < 0.05, se crea un nuevo modelo de supervivencia.

```{r}
# Variables a tener en cuenta en el siguiente modelo
var_imp <- sort(r_fit.all_vars$variable.importance, decreasing = TRUE)
which(var_imp > 0, arr.ind = TRUE)
r_fit.selec_vars <- ranger(Surv(time = time_monitored, event = vital_status) ~  age + tobacco_smoking_history + alcohol_consumption, data = dataset_survival,
                           num.trees = 525,
                           importance = "permutation",
                           splitrule = "extratrees",
                           num.random.splits = 20,
                           scale.permutation.importance = TRUE,
                           verbose = TRUE)

surv_prob <- data.frame(r_fit.selec_vars$survival)
avg_prob_selecvars <- sapply(surv_prob, mean)

df <- data.frame(r_fit.selec_vars$unique.death.times, avg_prob_selecvars, rep("RF", length(r_fit.selec_vars$unique.death.times)))
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

# Plot importancias
var_imp <- data.frame(sort(round(r_fit.selec_vars$variable.importance, 4), decreasing = TRUE))
names(var_imp) <- "importance"
var_imp

# Calcular el p-value para ver si las variables son representativas o no para el modelo
importance_pvalues(r_fit.selec_vars, method = "altmann", data = dataset_survival, formula = Surv(time = time_monitored, event = vital_status) ~  age + gender + tobacco_smoking_history + alcohol_consumption + tumor_size_in_cm)
```
En el nuevo modelo se observa que la variable del historial de consumo de tabaco del paciente ha dejado de ser relevante, por lo que se puede concluir que las variables más determinantes a la hora de predecir la supervivencia del paciente son el consumo de alcohol y la edad.

## COMPARACIÓN DE LAS CURVAS

Se comparan los 4 modelos obtenidos empleando la regresión de Cox y el algoritmo RF para todas las variables y sus selecciones de forma gráfica y mediante la extracción de sus respectivos valores de ROC.

```{r}
concordance_vals <- c((cox.model.all_vars[["concordance"]][["concordance"]]), (cox.model.select_vars[["concordance"]][["concordance"]]), (1 - r_fit.all_vars$prediction.error), (1 - r_fit.selec_vars$prediction.error))
names(concordance_vals) <- c("COX_ALL", "COX_SELECT", "RF_ALL", "RF_SELECT")

concordance_vals

rf_i <- rep("RF", length(r_fit.all_vars$unique.death.times))
rf_df <- data.frame(r_fit.all_vars$unique.death.times, avg_prob_allvars, rf_i)
names(rf_df) <- c("Time","Survival","Model")

rf_selec_i <- rep("RF SELEC. VARS.", length(r_fit.selec_vars$unique.death.times))
rf_selec_df <- data.frame(r_fit.selec_vars$unique.death.times, avg_prob_selecvars, rf_selec_i)
names(rf_selec_df) <- c("Time","Survival","Model")

cox_i <- rep("COX", length(cox.model.all_vars.fit$time))
cox_df <- data.frame(cox.model.all_vars.fit$time, cox.model.all_vars.fit$surv, cox_i)
names(cox_df) <- c("Time","Survival","Model")

cox_select_i <- rep("COX SELEC. VARS.", length(cox.model.select_vars.fit$time))
cox_select_df <- data.frame(cox.model.select_vars.fit$time, cox.model.select_vars.fit$surv, cox_select_i)
names(cox_select_df) <- c("Time","Survival","Model")

models_data_list <- rbind(rf_df, rf_selec_df, cox_df, cox_select_df)
df <- data.frame(DAY = round(cox.model.all_vars.fit$time[c((1:10)*14)], digits = 2), COX = round(cox.model.all_vars.fit$surv[c((1:10)*14)], digits = 2), COX_SLCT = round(cox.model.select_vars.fit$surv[c((1:10)*14)], digits = 2), RF = round(avg_prob_allvars[c((1:10)*14)], digits = 2), RF_SLCT = round(avg_prob_selecvars[c((1:10)*14)], digits = 2))
df_t <- transpose(df)
rownames(df_t) <- colnames(df)
df <- df_t
df.table <- tibble(x = 450, y = 1, tb = list(df))

ggplot(models_data_list, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + xlim(0,  max(dataset_survival$time_monitored)) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black") + geom_table(data = df.table, aes(x, y, label = list(df)), table.rownames = TRUE, table.colnames = FALSE, table.theme = ttheme_gtlight)
```
Para la evaluación de los modelos, todos devuelven el índice de concordancia o el c-index. De todos los modelos creados, el de Cox tiene el valor más alto, siendo este modelo el mejor en lo que respecta a las predicciones.
