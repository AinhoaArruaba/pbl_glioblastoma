---
title: "Detección GBM - analisis de los factores de riesgo"
output: html_notebook
---

```{r library load}
library(jsonlite)
library(corrplot)
library(Amelia)
library(caret)
library(e1071)
library(survival)
library(ranger)
library(mice)
library(RColorBrewer)
library(gridExtra)
library(ggplot2)
library(ggpmisc)
library(data.table)
library(dplyr)
library(tidyr)
library(purrr)

```

Este script muestra los pasos seguidos para el análisis de los factores de riesgo que pueden llevar al desarrollo de un glioblastoma multiforme (GBM) y no sobrevivir. Además, se incluyen también las características extraidas de los escáneres MRI de los pacientes.


```{r load dataset}
load(file = 'dataset_images_12month.Rda')

dataset_images_12month$cause_of_death_at_12months_follow_up <- as.factor(dataset_images_12month$cause_of_death_at_12months_follow_up)
dataset_images_12month$vital_status_at_12months_follow_up <- as.factor(dataset_images_12month$vital_status_at_12months_follow_up)
dataset_images_12month$gender <- as.factor(dataset_images_12month$gender)

```

# Cargar características extraidas de las imágenes

Hay que cargar el fichero CSV creado a partir de las características extraidas de las imágenes y unirlo con el dataset de los factores de riesgo usando el ID de los pacientes. Además, como no se disponen imágenes de todos los pacientes, se eliminarán aquellos pacientes de los que solo se dispongan metadatos. Se cambia la forma en la que estaban representados los NA en el CSV de las características para que coincida con el dataset de los factores de riesgo.

```{r}
filename <- "features/features_07_06.csv"
dataset_features <- read.csv(filename, header=TRUE)
dataset_features[dataset_features == "NaN"] <- NA
```

# Ajustar el nuevo dataset

Hay que comprobar si hace falta ajustar el tipo de dato de ciertas variables.

```{r}
sapply(dataset_features, class)
dataset_features$case_id <- as.factor(dataset_features$case_id)
dataset_features$tumor_mri_type <- as.factor(dataset_features$tumor_mri_type)
dataset_features$edema_mri_type <- as.factor(dataset_features$edema_mri_type)
```

## EXPLORATORY DATA ANALYSIS

* Debido a que algunos de los NA presentes en el dataset de las características se dan en casos en los que no es posible calcular esas características porque no se ha encontrado ningún tumor o edema por ejemplo, se sustituirán estos valores por un valor extremo como puede ser "-99999". Así, se ve que estas entradas son especiales y se podrán tener en cuenta. Esto se da cuando el volumen del edema o del tumor es 0 y tiene algún NA.

* Aun así, hay una excepción para los casos anteriores. Los casos en los que todos los valores son NA (incluyendo el volumen del tumor o del edema) deberán ser imputados ya que no significa que no se haya encontrado ningún tumor, sino que no se dispone de un escáner para analizarlo. También hay algún caso donde se ha detectado una anomalía pero existe al menos un NA. Estos NA no se cambiarán para que sean imputados después.

```{r}
tumor_volume_0_DF <- dataset_features[ which( dataset_features$tumor_volume == 0), ]
edema_volume_0_DF <- dataset_features[ which( dataset_features$edema_volume == 0), ]
dataset_na <- dataset_features[ which( is.na(dataset_features$tumor_mri_type) | is.na(dataset_features$edema_mri_type)) , ]
dataset_features <- dataset_features[ which( dataset_features$tumor_volume != 0 & dataset_features$edema_volume != 0) , ]

# Fill tumor values
index <- tumor_volume_0_DF$tumor_volume == 0
index[is.na(index)] <- FALSE
tumor_volume_0_DF[which(rowSums(is.na(tumor_volume_0_DF[index, c(4:27)])) > 10), c(4:27)] <- -99999

# Fill edema values
index <- edema_volume_0_DF$edema_volume == 0
index[is.na(index)] <- FALSE
edema_volume_0_DF[which(rowSums(is.na(edema_volume_0_DF[index, c(30:53)])) > 10), c(30:53)] <- -99999

dataset_features <- rbind(dataset_features, tumor_volume_0_DF, edema_volume_0_DF, dataset_na)

dataset_images_merge <- merge(dataset_images_12month, dataset_features, by="case_id", all=TRUE)
dataset_images_merge <- dataset_images_merge[!is.na(dataset_images_merge$tumor_volume),]
```

En este dataset se diferencian tres variables de clase distintas: cause_of_death_at_12months_follow_up o la causa de la muerte si es que la hay a los 12 meses, vital_status_at_12months_follow_up o el estado del paciente (vivo/muerto) a los 12 meses y life_expectancy o los dias que han pasado desde el diagnóstico del GBM hasta su muerte si es que la hay.

```{r EDA}
set.seed(173)
dataset_images_merge_red <- dataset_images_merge

# Missing values
missmap(dataset_images_merge_red, col=c("black", "grey"), legend=FALSE)

cause_of_death_index <- which(names(dataset_images_merge_red) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
vital_status_index <- which(names(dataset_images_merge_red) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
life_expectancy_index <- which(names(dataset_images_merge_red) == 'life_expectancy', arr.ind = TRUE)

dataset_images_merge_red[c(cause_of_death_index, vital_status_index, life_expectancy_index)] <- NULL 

# Elminar las entradas con más del 30% de las variables con NA
# Tamaño del dataset antes de eliminar entradas
dim(dataset_images_merge_red)
dataset_images_merge_red <- dataset_images_merge_red[which(rowMeans(!is.na(dataset_images_merge_red)) > 0.7), ]
dataset_images_merge <- dataset_images_merge[which(rowMeans(!is.na(dataset_images_merge[, -c(cause_of_death_index, vital_status_index, life_expectancy_index)])) > 0.7), ]

# Eliminar variables con más del 40% de los valores con NA
dataset_images_merge_red <- cbind(dataset_images_merge_red[, which(colMeans(!is.na(dataset_images_merge_red[,])) > 0.6)], dataset_images_merge[,c(cause_of_death_index, vital_status_index, life_expectancy_index)])

cause_of_death_index <- which(names(dataset_images_merge_red) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
vital_status_index <- which(names(dataset_images_merge_red) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
life_expectancy_index <- which(names(dataset_images_merge_red) == 'life_expectancy', arr.ind = TRUE)

numeric_var_indexes_all <- c(which(sapply(dataset_images_merge_red, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_images_merge_red, class) == 'integer', arr.ind = TRUE))
numeric_var_indexes <- numeric_var_indexes_all[-which(numeric_var_indexes_all ==  life_expectancy_index, arr.ind = TRUE)]

non_numeric_var_indexes_all <- which(sapply(dataset_images_merge_red, class) == 'factor', arr.ind = TRUE)
non_numeric_var_indexes <- non_numeric_var_indexes_all[-which(non_numeric_var_indexes_all ==  cause_of_death_index, arr.ind = TRUE)]
non_numeric_var_indexes <- non_numeric_var_indexes[-which(non_numeric_var_indexes ==  vital_status_index, arr.ind = TRUE)]

# Tamaño del dataset tras eliminar entradas
dim(dataset_images_merge_red)

missmap(dataset_images_merge_red, col=c("black", "grey"), legend=FALSE)

# Histogramas de las variables numéricas
par(mfrow=c(1, 4))
for(i in 1:length(numeric_var_indexes)) {
    hist(dataset_images_merge_red[,numeric_var_indexes[i]], main=names(dataset_images_merge_red)[numeric_var_indexes[i]])
}

# Barplots de las variables no numéricas
par(mfrow=c(1, 3))
for(i in 1:length(non_numeric_var_indexes)) {
    barplot(table(dataset_images_merge_red[,non_numeric_var_indexes[i]]), main=names(dataset_images_merge_red)[non_numeric_var_indexes[i]], las=2)
}

# Correlación de las variables numéricas
# Se muestran solo las variables con una correlación mayor a 0.85 para facilitar su visualización.
par(mfrow=c(1, 1))
correlation_numeric_vars_initial <- cor(dataset_images_merge_red[, numeric_var_indexes], use = "complete.obs")
correlation_numeric_vars <- correlation_numeric_vars_initial
correlation_numeric_vars[correlation_numeric_vars == 1] <- NA 

correlation_numeric_vars <- as.data.frame(as.table(correlation_numeric_vars))
correlation_numeric_vars <- na.omit(correlation_numeric_vars)
sig <- 0.75
correlation_numeric_vars <- subset(correlation_numeric_vars, abs(Freq) > sig)
correlation_numeric_vars <- correlation_numeric_vars[order(-abs(correlation_numeric_vars$Freq)),] 
print(correlation_numeric_vars)
mtx_corr <- reshape2::acast(correlation_numeric_vars, Var1~Var2, value.var="Freq")
corrplot(mtx_corr, is.corr=FALSE, tl.col="black", na.label=" ", tl.cex=0.5)

# Valores del skewness
for(i in 1:length(numeric_var_indexes)){
  print(names(dataset_images_merge_red)[numeric_var_indexes[i]])
  print(skewness(dataset_images_merge_red[, numeric_var_indexes[i]], na.rm = TRUE))
}

```
De los datos extraidos en este punto se han realizado las siguientes observaciones.

* En lo que respecta a los valores que faltan (NA), el mapa presenta una alta cantidad de NA para las variables:

  - ethnicity
  - race
  - years_high_alcohol_quantity_consumed
  - number_of_pack_years_smoked
  - alcohol consumption
  - tobacco_smoking_history
  - life_expectancy
  
* De las cuales las primeras dos no llegan al 60% de datos completos y las otras cinco sí. Se ha decidido el eliminar aquellas variables que no llegan al 60%, teniendo que imputar los valores de las variables years_high_alcohol_quantity_consumed y number_of_pack_years_smoked en la fase de preprocesado.

* La variable life_expectancy también contiene muchos valores NA pero no preocupan por el momento, ya que estos valores se corresponden a pacientes que siguen vivos. Además, debido a que el dataset corresponde a datos que se han ido recogiendo durante más de un año, la variable también contiene valores mayores que 365. Esto significa que estos pacientes estaban vivos a los 12 meses pero han fallecido mientras estaban en seguimiento más adelante. Aun así, esto no se puede saber a los 12 meses que es cuando se está realizando el análisis por lo que estas entradas se tienen que reemplazar por NA.

* Además, la variable time_monitored también contiene valores mayores que 365 pero como se está realizando el análisis a los 12 meses, se decide limitar estos valores a 365.

* En la variable tumor_size hay 2 valores NA que tendrán que ser imputados.

* 1 de estas entradas NA corresponde a 1 paciente del cual se tienen imágenes MRI de donde se han sacado características pero no se disponen metadatos de este paciente. Por ello, se decide eliminar este caso.

* Además, las entradas que no llegan al 70% de variables definidas se han eliminado del dataset, eliminando un total de 3 entradas.

* En general, los valores del skewness no son muy altos, solo algunas características extraidas tienen un valor mayor. Para no cambiar los valores de las características extraidas, no se plantea la corrección del skewness en el apartado de preprocesamiento.

## Limitación de variables a 12 meses
Ya que se va a realizar el análisis a los 12 meses, se limitan las variables a este intervalo.

```{r}
summary(dataset_images_merge_red$life_expectancy)
dataset_images_merge_red[which(dataset_images_merge_red$life_expectancy > 365, arr.ind = TRUE), names(dataset_images_merge_red) == 'life_expectancy'] <- NA
summary(dataset_images_merge_red$life_expectancy)

summary(dataset_images_merge_red$time_monitored)
dataset_images_merge_red[which(dataset_images_merge_red$time_monitored > 365, arr.ind = TRUE), names(dataset_images_merge_red) == 'time_monitored'] <- 365
summary(dataset_images_merge_red$time_monitored)
```

## Eliminación de pacientes sin metadatos
Se van a eliminar los pacientes detectados sin metadatos.

```{r}
dim(dataset_images_merge_red)
dataset_images_merge_red <- dataset_images_merge_red[!is.na(dataset_images_merge_red$age),]
dim(dataset_images_merge_red)
```

## Eliminación de variables altamente correladas
Se van a eliminar las variables altamente correlacionadas del dataset para evitar problemas de multicolinealidad y overfitting.

```{r}
set.seed(173)
case_id_index <- which(names(dataset_images_merge_red) == 'case_id', arr.ind = TRUE)
dim(dataset_images_merge_red)
# Buscar atributos altamente correlados
cutoff <- 0.75
highlyCorrelated <- findCorrelation(correlation_numeric_vars_initial, cutoff=cutoff)

# Crear un nuevo dataset sin las variables altamente correladas
dataset_images_merge_red_num <- dataset_images_merge_red[,numeric_var_indexes]
dataset_images_12month_features_num <- dataset_images_merge_red_num[,-highlyCorrelated]

dim(dataset_images_12month_features_num)

# Volver a introducir variables no numéricas
dataset_images_12month_features <- as.data.frame(cbind(dataset_images_12month_features_num, life_expectancy = dataset_images_merge_red[,life_expectancy_index], dataset_images_merge_red[,non_numeric_var_indexes_all]))

cause_of_death_index <- which(names(dataset_images_12month_features) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
vital_status_index <- which(names(dataset_images_12month_features) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
life_expectancy_index <- which(names(dataset_images_12month_features) == 'life_expectancy', arr.ind = TRUE)
```
* Se han eliminado un total de 31 variables correladas.

Por cada variable de clase se crea un dataset distinto con el objetivo de analizarlas por separado.

## Análisis del estado del paciente (vivo/muerto)

Se analiza los valores de las variables dependiendo del estado del paciente, si está vivo o muerto, y la relación que tienen con la variable de clase.

```{r EDA vital status}
dataset_vital_status <- dataset_images_12month_features[, -c(life_expectancy_index, cause_of_death_index)]

class_val_index <- which(names(dataset_vital_status) == 'vital_status_at_12months_follow_up', arr.ind = TRUE)
numeric_var_indexes_vital <- c(which(sapply(dataset_vital_status, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_vital_status, class) == 'integer', arr.ind = TRUE))
non_numeric_var_indexes_vital <- which(sapply(dataset_vital_status, class) == 'factor', arr.ind = TRUE)
non_numeric_var_indexes_vital <- non_numeric_var_indexes_vital[-which(non_numeric_var_indexes_vital ==  class_val_index, arr.ind = TRUE)]

summary(dataset_vital_status)

# Boxplots para las variables numéricas
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[1:4]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[5:8]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[9:12]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[13:16]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[17:20]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[21:24]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_vital_status[, numeric_var_indexes_vital[25:27]],
            y=dataset_vital_status$vital_status_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(3, 1))

#Barplots
barplot(table(dataset_vital_status[, c(non_numeric_var_indexes_vital[2], class_val_index)]), 
        main = names(dataset_vital_status)[non_numeric_var_indexes_vital[2]], 
        col = brewer.pal(n = 4, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 100),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("= or < 1-2 drinks/day",
                                      "> 1-2 drinks/day", "Consumed in the past", "Lifelong non-drinker"),
                           fill = brewer.pal(n = 4, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_vital_status[, c(non_numeric_var_indexes_vital[3], class_val_index)]), 
        main = names(dataset_vital_status)[non_numeric_var_indexes_vital[3]], 
        col = brewer.pal(n = 2, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Female", "Male"),
                           fill = brewer.pal(n = 2, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_vital_status[, c(non_numeric_var_indexes_vital[4], class_val_index)]), 
        main = names(dataset_vital_status)[non_numeric_var_indexes_vital[4]], 
        col = brewer.pal(n = 5, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Reformed smoker (<15)", "Reformed smoker (>15)", "Reformed smoker (?)",
                                      "Current smoker", "Lifelong non-smoker"),
                           fill = brewer.pal(n = 5, name = "Set2"),
                           ncol = 1))


# Class imbalance
cbind(Label_freq=table(dataset_vital_status$vital_status_at_12months_follow_up), Label_percent=prop.table(table(dataset_vital_status$vital_status_at_12months_follow_up))*100)
```
Con los datos obtenidos se concluyen los siguientes puntos.

* Se observa que el dataset está más o menos balanceado (43.75% de pacientes muertos y 56.25% vivos).

* Analizando los boxplots y los barplots creados, no se puede determinar una separación clara entre las distintas variables de clase. La realidad es que hay ciertas tendencias, por ejemplo, parece que la mayoría de los que han muerto tenían un tamaño de tumor y de edema algo más alto como mediana. También se han observado ciertas variaciones en la distancia en el eje Y desde el centroide del cerebro al centroide del tumor, el contraste de la matriz de coocurrencia del tumor y en la compacidad del tumor. Pero no se observa que ninguna variable sea determinante para una predicción clara del estado del paciente. También parece que los que nunca han fumado tienden a sobrevivir.

# Análisis de la causa de muerte

Se analiza la causa de la muerte siendo en su mayoría por GBM, aunque aparecen otras posibles causas. Además, hay que tener un cuenta que casi el 60% de los pacientes siguen vivos.

```{r EDA cause of death}
dataset_cause <- dataset_images_12month_features
dataset_cause <- dataset_cause[which(dataset_cause$vital_status_at_12months_follow_up == 'Deceased', arr.ind = TRUE), ]

dataset_cause <- dataset_cause[, -c(life_expectancy_index, vital_status_index)]
class_val_index <- which(names(dataset_cause) == 'cause_of_death_at_12months_follow_up', arr.ind = TRUE)
numeric_var_indexes_cause <- c(which(sapply(dataset_cause, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_cause, class) == 'integer', arr.ind = TRUE))
non_numeric_var_indexes_cause <- which(sapply(dataset_cause, class) == 'factor', arr.ind = TRUE)
non_numeric_var_indexes_cause <- non_numeric_var_indexes_cause[-which(non_numeric_var_indexes_cause ==  class_val_index, arr.ind = TRUE)]
dataset_cause <- droplevels(dataset_cause)

summary(dataset_cause)

# Boxplots for numeric variables
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[1:4]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[5:8]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[9:12]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[13:16]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[17:20]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[21:24]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(4, 1))
featurePlot(x=dataset_cause[, numeric_var_indexes_cause[25:27]],
            y=dataset_cause$cause_of_death_at_12months_follow_up, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 30)),
            layout = c(3, 1))

# Barplots for non-numeric variables
barplot(table(dataset_cause[, c(non_numeric_var_indexes_cause[2], class_val_index)]), 
        main = names(dataset_cause)[non_numeric_var_indexes_cause[2]], 
        col = brewer.pal(n = 4, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 100),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("= or < 1-2 drinks/day",
                                      "> 1-2 drinks/day", "Consumed in the past", "Lifelong non-drinker"),
                           fill = brewer.pal(n = 4, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_cause[, c(non_numeric_var_indexes_cause[3], class_val_index)]), 
        main = names(dataset_cause)[non_numeric_var_indexes_cause[3]], 
        col = brewer.pal(n = 2, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Female", "Male"),
                           fill = brewer.pal(n = 2, name = "Set2"),
                           ncol = 1))
barplot(table(dataset_cause[, c(non_numeric_var_indexes_cause[4], class_val_index)]), 
        main = names(dataset_cause)[non_numeric_var_indexes_cause[4]], 
        col = brewer.pal(n = 5, name = "Set2"),
        las = 2,
        xlim = c(0, 4),
        ylim = c(0, 40),
        legend.text = TRUE,
        args.legend = list(x = "topright", 
                           legend = c("Reformed smoker (<15)", "Reformed smoker (>15)", "Reformed smoker (?)",
                                      "Current smoker", "Lifelong non-smoker"),
                           fill = brewer.pal(n = 5, name = "Set2"),
                           ncol = 1))

# Class imbalance
cbind(Label_freq=table(dataset_cause$cause_of_death_at_12months_follow_up), Label_percent=prop.table(table(dataset_cause$cause_of_death_at_12months_follow_up))*100)

```
Con los datos obtenidos se concluyen los siguientes puntos.

* Se observa que el dataset está no está balanceado (71.43% de pacientes muertos a causa de GBM, 23.81% por Malignant Brain Neoplasm y 4.76% por Postoperative Edema). Además, solo hay un paciente que ha muerto por Postoperative Edema por lo que no se pueden sacar unas conclusiones concluyentes respecto a esta causa.

* En lo que respecta a los boxplots y barplots empleados, se observa que ciertas variables muestran una ligera diferencia entre clases. Si se ha observado que aquellos pacientes que nunca han fumado o nunca han bebido suelen morir por el GBM sin otras complicaciones. Otras variables como el volumen del edema, el peso del paciente, o la media de intensidad del tumor también diferencian a pacientes con distintas causas de muerte pero esta diferencia no es muy significativa.

* Se observa que ciertas características del paciente muerto por un edema postoperatorio difieren bastante de las de los demás pero, como se ha dicho antes, un paciente no es suficiente para sacar conclusiones.

# Análisis de la esperanza de vida

La esperanza de vida se corresponde con los dias que transcurren desde la primera diagnósis hasta la muerte.

```{r EDA life expectancy}
dataset_life_expect <- dataset_images_12month_features

dataset_life_expect <- dataset_life_expect[, -c(cause_of_death_index, vital_status_index)]
class_val_index <- which(names(dataset_life_expect) == 'life_expectancy', arr.ind = TRUE)
numeric_var_indexes_life_expect <- c(which(sapply(dataset_life_expect, class) == 'numeric', arr.ind = TRUE), which(sapply(dataset_life_expect, class) == 'integer', arr.ind = TRUE))
numeric_var_indexes_life_expect <- numeric_var_indexes_life_expect[-which(numeric_var_indexes_life_expect ==  class_val_index, arr.ind = TRUE)]
non_numeric_var_life_expect <- which(sapply(dataset_life_expect, class) == 'factor', arr.ind = TRUE)

dataset_life_expect <- droplevels(dataset_life_expect)
summary(dataset_life_expect)
# Scatter plots for numeric variables
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[1:4]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[5:8]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[9:12]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[13:16]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[17:20]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[21:24]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(2, 2))
featurePlot(x = dataset_life_expect[, numeric_var_indexes_life_expect[25:27]], 
            y = dataset_life_expect$life_expectancy,
            plot = "scatter",
            type = c("p", "smooth"),
            span = 1,
            layout= c(1, 3))

# Boxplots
featurePlot(y=dataset_life_expect[, non_numeric_var_life_expect[2]],
            x=dataset_life_expect$life_expectancy, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 10)))
featurePlot(y=dataset_life_expect[, non_numeric_var_life_expect[3]],
            x=dataset_life_expect$life_expectancy, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 0)))
featurePlot(y=dataset_life_expect[, non_numeric_var_life_expect[4]],
            x=dataset_life_expect$life_expectancy, plot="box",
            scales = list(y = list(relation="free"),
                          x = list(rot = 10)))

# Class variable
plot(density(dataset_life_expect$life_expectancy[which(!is.na(dataset_life_expect$life_expectancy))]), main=names(dataset_life_expect)[class_val_index])
```
* Se puede ver que ciertas variables como el tamaño del tumor en cm, el BMI o el volumen del edema muestran una relación más o menos lineal con la esperanza de vida. En otras, en cambio, esta relación no está tan clara.

## IMPUTACIÓN DE LAS VARIABLES

Con el objetivo de poder analizar el impacto que todas las variables tienen en la supervivencia del paciente y calcular las regresiones de Cox y RandomForest, se procede a la imputación de los valores definidos como NA en el dataset. Para la imputación de las variables se emplea el método Cart que utiliza la clasificación y árboles de regresión.

```{r}
# Cantidad de valores NA que hay que imputar
sum(is.na(dataset_images_12month_features))

na_loc <- which(is.na(dataset_images_12month_features), arr.ind=TRUE)
na_loc_columns <- unique(na_loc[,2])
na_loc_columns <- na_loc_columns[-which(na_loc_columns == life_expectancy_index, arr.ind=TRUE)]

# Variables con valores NA presentes
names(dataset_images_12month_features)[na_loc_columns]
case_id_index <- which(names(dataset_images_12month_features) == 'case_id', arr.ind = TRUE)

dataset_images_12month_features_completed <- dataset_images_12month_features[, -c(life_expectancy_index, case_id_index)]

imp_pmm <- mice(dataset_images_12month_features_completed, m = 1, method= "cart", printFlag = FALSE, seed = 7)
dataset_images_12month_features_completed <- complete(imp_pmm)

for(row in 1:dim(dataset_images_12month_features_completed)[1]){
  if(dataset_images_12month_features_completed[row, ]$tobacco_smoking_history == "Lifelong non-smoker: Less than 100 cigarettes smoked in lifetime" && dataset_images_12month_features_completed[row, ]$number_of_pack_years_smoked != 0) {
    dataset_images_12month_features_completed[row, ]$number_of_pack_years_smoked <- 0
  } else if(dataset_images_12month_features_completed[row, ]$tobacco_smoking_history != "Lifelong non-smoker: Less than 100 cigarettes smoked in lifetime" && dataset_images_12month_features_completed[row, ]$number_of_pack_years_smoked == 0){
    dataset_images_12month_features_completed[row, ]$number_of_pack_years_smoked <- NA
  }
  if(dataset_images_12month_features_completed[row, ]$alcohol_consumption == "Alcohol consumption more than 2 drinks per day for men and more than 1 drink per day for women" && dataset_images_12month_features_completed[row, ]$years_high_alcohol_quantity_consumed == 0) {
    dataset_images_12month_features_completed[row, ]$years_high_alcohol_quantity_consumed <- NA
  } else if(dataset_images_12month_features_completed[row, ]$alcohol_consumption == "Lifelong non-drinker" && dataset_images_12month_features_completed[row, ]$years_high_alcohol_quantity_consumed != 0){
    dataset_images_12month_features_completed[row, ]$years_high_alcohol_quantity_consumed <- 0
  }
}

imp_pmm <- mice(dataset_images_12month_features_completed, m = 1, method= "cart", printFlag = FALSE, seed = 3)
dataset_images_12month_features_completed <- complete(imp_pmm)

# Cantidad de valores NA después de imputar
print(sum(is.na(dataset_images_12month_features_completed)))
```

* Podemos ver que el dataset imputado no contiene ningún valor NA.

* Los únicos valores NA presentes ahora son los de life_expectancy que corresponden a pacientes vivos.

## REGRESIÓN DE COX

El primer método empleado para determinar las probabilidades de supervivencia del paciente es la regresión de Cox. Una vez contamos con el dataset con los valores imputados, procedemos a calcular la regresión de Cox con todas las variables disponibles.

 * Aun así, tras haber probado con todas las variables se excluyen "gender" y "tobacco_smoking_history" ya que el modelo no converge con estas variables.

```{r}
dataset_survival <- dataset_images_12month_features_completed
dataset_survival$vital_status_at_12months_follow_up <- as.numeric(dataset_survival$vital_status_at_12months_follow_up)
dataset_survival$vital_status_at_12months_follow_up[which(dataset_survival$vital_status_at_12months_follow_up == 2)] <- 0

set.seed(173)

cox.model.all_vars <- coxph(Surv(time_monitored, vital_status_at_12months_follow_up) ~ bmi + number_of_pack_years_smoked + tumor_size_in_cm + years_high_alcohol_quantity_consumed + tumor_volume + tumor_dist_x + tumor_dist_y + tumor_compactness + tumor_ent + tumor_smoothness + tumor_glcm_contrast + tumor_Hu_1 + tumor_Hu_2 + tumor_Hu_3 + tumor_Hu_6 + edema_volume + edema_dist_x + edema_dist_y + edema_compactness + edema_kur + edema_smoothness + edema_glcm_contrast + edema_glcm_correlation + edema_Hu_3 + age + height_in_cm + alcohol_consumption, data = dataset_survival)
summary(cox.model.all_vars, digits = 3)

cox.model.all_vars.fit <- survfit(cox.model.all_vars)

df <- data.frame(cox.model.all_vars.fit$time, cox.model.all_vars.fit$surv, "Cox")
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

anova(cox.model.all_vars)
```

Mediante los tests ANOVA se ha determinado la relevancia de las variables en el modelo de Cox. La mayoría de ellos no parecen ser relevantes (p < 0.05), estando por debajo de ese valor únicamente las variables de "tumor_Hu_3", "edema_glcm_correlation" y "age". Para asegurarnos de que esto se cumple, creamos un segundo modelo de Cox solo con las variables determinadas como relevantes y comparamos los resultados de los dos modelos mediante los tests ANOVA.

* Tras haber probado con estas dos variables determinantes, se observa que la diferencia entre ambos modelos es relevante por lo que se incluyen también las variables "tumor_size_in_cm" y "height_in_cm" ya que son las que más cerca están de ser relevantes.

```{r}
set.seed(173)

cox.model.select_vars <- coxph(Surv(time_monitored, vital_status_at_12months_follow_up) ~ tumor_Hu_3 + edema_glcm_correlation + age + tumor_size_in_cm + height_in_cm, data = dataset_survival)
# summary(cox.model.select_vars, digits = 3)
cox.model.select_vars.fit <- survfit(cox.model.select_vars)
summary(cox.model.select_vars, digits = 3)

df <- data.frame(cox.model.select_vars.fit$time, cox.model.select_vars.fit$surv, "Cox")
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

anova(cox.model.select_vars)
anova(cox.model.select_vars, cox.model.all_vars, test = "LRT")
```

El test ANOVA muestra un valor p > 0.05 por lo que podemos concluir que la diferencia entre ambos modelos no es relevante, confirmando que las tres variables seleccionadas son suficiente para calcular el modelo de supervivencia y que son las más determinantes a la hora de predecir las probabilidades de supervivencia del paciente que padece de GBM.

## RANDOM FOREST

Para comparar el modelo de supervivencia obtenido mediante la regresión de Cox con otro modelo se implementa otro modelo basádo en el algoritmo Random Forest.  Se calcula el modelo de supervivencia de todas las variables (incluyendo las variables excluidas en la regresión de Cox) y obtenemos las importancias asignadas a cada una de las variables por el modelo mediante el método de permutación. Esta métrica nos permite determinar como aumenta el error en la predicción al eliminar la variable.

```{r}
set.seed(173)

names(dataset_survival) <- janitor::make_clean_names(names(dataset_survival), use_make_names = TRUE)

r_fit.all_vars <- ranger(Surv(time = time_monitored, event = vital_status_at_12months_follow_up) ~ bmi + number_of_pack_years_smoked + tumor_size_in_cm + years_high_alcohol_quantity_consumed + tumor_volume + tumor_dist_x + tumor_dist_y + tumor_compactness + tumor_ent + tumor_smoothness + tumor_glcm_contrast + tumor_hu_1 + tumor_hu_2 + tumor_hu_3 + tumor_hu_6 + edema_volume + edema_dist_x + edema_dist_y + edema_compactness + edema_kur + edema_smoothness + edema_glcm_contrast + edema_glcm_correlation + edema_hu_3 + age + height_in_cm + alcohol_consumption + gender + tobacco_smoking_history, data = dataset_survival,
                         num.trees = 525,
                         importance = "permutation",
                         splitrule = "extratrees",
                         num.random.splits = 20,
                         scale.permutation.importance = TRUE,
                         verbose = TRUE,
                         seed = 5)

surv_prob <- data.frame(r_fit.all_vars$survival)
avg_prob_allvars <- sapply(surv_prob, mean)

df <- data.frame(r_fit.all_vars$unique.death.times, avg_prob_allvars, rep("RF", length(r_fit.all_vars$unique.death.times)))
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

# Plot importancias
var_imp <- data.frame(sort(round(r_fit.all_vars$variable.importance, 4), decreasing = TRUE))
names(var_imp) <- "importance"
var_imp
```

Con las variables de más importancia, es decir, aquellas que introducen un mayor error en la predicción en caso de eliminarse, se crea un nuevo modelo de supervivencia.

```{r}
set.seed(173)

# Variables a tener en cuenta en el siguiente modelo
var_imp <- sort(r_fit.all_vars$variable.importance, decreasing = TRUE)
which(var_imp > 0, arr.ind = TRUE)
r_fit.selec_vars <- ranger(Surv(time = time_monitored, event = vital_status_at_12months_follow_up) ~ tumor_size_in_cm + tumor_hu_3 + tumor_ent + tumor_hu_2 + tumor_hu_6 + gender + tumor_glcm_contrast + tobacco_smoking_history + tumor_smoothness + edema_glcm_correlation, data = dataset_survival,
                           num.trees = 525,
                           importance = "permutation",
                           splitrule = "extratrees",
                           num.random.splits = 20,
                           scale.permutation.importance = TRUE,
                           verbose = TRUE,
                           seed = 5)

surv_prob <- data.frame(r_fit.selec_vars$survival)
avg_prob_selecvars <- sapply(surv_prob, mean)

df <- data.frame(r_fit.selec_vars$unique.death.times, avg_prob_selecvars, rep("RF", length(r_fit.selec_vars$unique.death.times)))
names(df) <- c("Time", "Survival", "Model")

ggplot(df, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black")

# Plot importancias
var_imp <- data.frame(sort(round(r_fit.selec_vars$variable.importance, 4), decreasing = TRUE))
names(var_imp) <- "importance"
var_imp
```
En el nuevo modelo se observa que las variables "edema_glcm_correlation", "gender" y "tumor_glcm_contrast" han dejado de ser relevantes, por lo que se puede concluir que las variables más determinantes a la hora de predecir la supervivencia del paciente son "tumor_size_in_cm", "tumor_ent", "tobacco_smoking_history", "tumor_smoothness", "tumor_hu_2", "tumor_hu_3", "tumor_hu_6", "edema_glcm_correlation", "gender" y "tumor_glcm_contrast".

## COMPARACIÓN DE LAS CURVAS

Se comparan los 4 modelos obtenidos empleando la regresión de Cox y el algoritmo RF para todas las variables y sus selecciones de forma gráfica y mediante la extracción de sus respectivos valores de ROC.

```{r}
concordance_vals <- c((cox.model.all_vars[["concordance"]][["concordance"]]), (cox.model.select_vars[["concordance"]][["concordance"]]), (1 - r_fit.all_vars$prediction.error), (1 - r_fit.selec_vars$prediction.error))
names(concordance_vals) <- c("COX_ALL", "COX_SELECT", "RF_ALL", "RF_SELECT")

print(concordance_vals)

rf_i <- rep("RF", length(r_fit.all_vars$unique.death.times))
rf_df <- data.frame(r_fit.all_vars$unique.death.times, avg_prob_allvars, rf_i)
names(rf_df) <- c("Time","Survival","Model")

rf_selec_i <- rep("RF SELEC. VARS.", length(r_fit.selec_vars$unique.death.times))
rf_selec_df <- data.frame(r_fit.selec_vars$unique.death.times, avg_prob_selecvars, rf_selec_i)
names(rf_selec_df) <- c("Time","Survival","Model")

cox_i <- rep("COX", length(cox.model.all_vars.fit$time))
cox_df <- data.frame(cox.model.all_vars.fit$time, cox.model.all_vars.fit$surv, cox_i)
names(cox_df) <- c("Time","Survival","Model")

cox_select_i <- rep("COX SELEC. VARS.", length(cox.model.select_vars.fit$time))
cox_select_df <- data.frame(cox.model.select_vars.fit$time, cox.model.select_vars.fit$surv, cox_select_i)
names(cox_select_df) <- c("Time","Survival","Model")

models_data_list <- rbind(rf_df, rf_selec_df, cox_df, cox_select_df)
df <- data.frame(DAY = round(cox.model.all_vars.fit$time[c((1:9)*2, 24)], digits = 2), COX = round(cox.model.all_vars.fit$surv[c((1:9)*2, 24)], digits = 2), COX_SLCT = round(cox.model.select_vars.fit$surv[c((1:9)*2, 24)], digits = 2), RF = round(avg_prob_allvars[c((1:9)*2, 24)], digits = 2), RF_SLCT = round(avg_prob_selecvars[c((1:9)*2, 24)], digits = 2))
df_t <- data.table::transpose(df)
rownames(df_t) <- colnames(df)
df <- df_t
df.table <- tibble(x = 10, y = 0.2, tb = list(df))

ggplot(models_data_list, aes(x = Time, y = Survival, color = Model)) + geom_line() + ylim(0, 1) + xlim(0,  max(dataset_survival$time_monitored)) + geom_hline(yintercept = 0.5, linetype="dashed", color = "black") + geom_table(data = df.table, aes(x, y, label = list(df)), table.rownames = TRUE, table.colnames = FALSE, table.theme = ttheme_gtlight)
```
Para la evaluación de los modelos, todos devuelven el índice de concordancia o el c-index. De todos los modelos creados, el de Cox con todas las variables tiene el valor más alto, siendo este modelo el mejor en lo que respecta a las predicciones.

## Guardar el dataset creado

Se va a guardar el dataset creado para la posterior creación de modelos.

```{r store datasets}
dataset_images_12month_features_completed <- droplevels(dataset_images_12month_features_completed)

save(dataset_images_12month_features_completed, file = 'dataset_images_12month_features_completed.Rda')

```
